# Ответы на вопросы по коду

## Вопрос 1
**В файле public\index.html мы используем тег main и внутри него секции с тегами div, зачем это сделано именно таким образом?**

### Полное аргументированное объяснение
Использование тега `<main>` и вложенных в него `<section>` (или `div` с соответствующими классами) обусловлено принципами **семантической верстки** (Semantic HTML).

1.  **Тег `<main>`**: Этот тег предназначен для обозначения основного, уникального содержимого страницы. Он сообщает браузерам и поисковым системам, где находится главная информация, исключая повторяющиеся элементы вроде шапки (`<header>`), подвала (`<footer>`) или боковых панелей. На странице должен быть только один видимый тег `<main>`.
2.  **Теги `<section>`**: Внутри `<main>` контент логически разделен на смысловые блоки. В вашем коде используются теги `<section class="panel">`. Тег `<section>` применяется для группировки тематически связанного контента (например, "Панель авторизации" и "Панель приложения"). Это лучше, чем просто `<div>`, так как дает понять, что внутри находится самостоятельный раздел документа.
3.  **Теги `<div>` внутри**: Внутри секций используются `<div>` (например, `<div class="panel-header">`, `<div class="field-group">`). Тег `<div>` — это универсальный контейнер без семантического значения. Он используется для создания структуры макета (layout) и стилизации (привязки CSS-классов).

**Итог:** Такая структура (`main` -> `section` -> `div`) делает код понятным для разработчиков, доступным для скринридеров (программ чтения с экрана) и правильным с точки зрения стандартов HTML5.

### Дополнительная информация
**Семантические теги:**
В HTML5 были введены теги, которые описывают *смысл* содержимого, а не его внешний вид:
*   `<header>` — вводная часть страницы или раздела.
*   `<nav>` — навигационные ссылки.
*   `<main>` — основное содержимое.
*   `<article>` — независимый, самодостаточный контент (например, пост в блоге).
*   `<aside>` — контент, косвенно связанный с основным (боковая панель).
*   `<footer>` — подвал страницы.

**Тег `<div>`:**
Это блочный элемент (block-level element). Он занимает всю доступную ширину и начинается с новой строки. Используется, когда ни один семантический тег не подходит, чисто для оформления.

---

## Вопрос 2
**В server\server.js есть функция writeJson, что она делает, каким образом, какие в нее данные входят и какие типы данных могут быть в языке JavaScript?**

### Полное аргументированное объяснение
Функция `writeJson` в файле `server\server.js` предназначена для **записи данных в файл в формате JSON**.

**Что она делает:**
1.  Принимает путь к файлу и данные.
2.  Преобразует данные (JavaScript-объект или массив) в строковый формат JSON.
3.  Асинхронно записывает эту строку в указанный файл, полностью перезаписывая его содержимое.

**Каким образом (разбор кода):**
```javascript
async function writeJson(filePath, payload) {
    const serialized = JSON.stringify(payload, null, 2);
    await writeFile(filePath, serialized, 'utf8');
}
```
*   `async`: Функция объявлена как асинхронная, что позволяет использовать внутри неё `await`.
*   `JSON.stringify(payload, null, 2)`: Встроенный метод JS.
    *   `payload`: данные для сериализации.
    *   `null`: функция замены (replacer), здесь не используется.
    *   `2`: количество пробелов для отступа. Это делает записанный JSON-файл читаемым для человека (pretty-print).
*   `await writeFile(...)`: Вызов функции записи файла из модуля `fs/promises`. Скрипт ждет завершения записи, прежде чем продолжить выполнение (или завершить функцию).
*   `'utf8'`: Кодировка файла.

### Дополнительная информация

**Параметры функции:**
1.  `filePath` (String): Абсолютный или относительный путь к файлу, куда нужно сохранить данные.
2.  `payload` (Любой сериализуемый тип): Данные, которые нужно сохранить. Обычно это Объект (`Object`) или Массив (`Array`).

**Типы данных в JavaScript:**
JavaScript является языком с динамической типизацией. Основные типы данных делятся на примитивы и объекты:

1.  **Примитивные типы (Primitives):**
    *   `Number`: Числа (целые и дробные), например `42`, `3.14`.
    *   `String`: Строки, например `'Привет'`, `"Hello"`.
    *   `Boolean`: Логический тип, `true` или `false`.
    *   `Null`: Специальное значение, означающее "ничего" или "пусто".
    *   `Undefined`: Значение переменной, которая была объявлена, но не инициализирована.
    *   `BigInt`: Для работы с очень большими целыми числами.
    *   `Symbol`: Уникальный идентификатор.

2.  **Объекты (Objects):**
    *   `Object`: Коллекция пар ключ-значение `{ name: "Ivan", age: 25 }`.
    *   `Array`: Упорядоченный список `[1, 2, 3]`. (Формально массивы в JS — это тоже объекты).
    *   `Date`, `RegExp`, `Map`, `Set` и другие встроенные объекты.

**Важно для JSON:**
Формат JSON поддерживает не все типы JS.
*   Поддерживает: `String`, `Number`, `Boolean`, `Null`, `Object`, `Array`.
*   **Не** поддерживает: `Undefined`, `Symbol`, `Function`, `Date` (преобразуется в строку).

---

## Вопрос 3
**Объясни почему не видно секцию с формой по загрузке информацию в базу данных, пока не написать логин?**

### Полное аргументированное объяснение
Секция с формой (элемент с `id="app-panel"`) изначально скрыта с помощью CSS-класса `hidden`.

1.  **В HTML:** В файле `index.html` у этой секции прописан класс: `<section class="panel hidden" id="app-panel">`. Класс `hidden` (определенный в `style.css`) задает свойство `display: none;`, что делает элемент невидимым.
2.  **В JavaScript:** Логика переключения видимости находится в функции `handleLogin`. Когда пользователь вводит логин и нажимает кнопку, скрипт:
    *   Проверяет, что поле не пустое.
    *   Удаляет класс `hidden` у панели приложения (`ui.appPanel.classList.remove('hidden')`), делая её видимой.
    *   Добавляет класс `hidden` панели авторизации (`ui.authPanel.classList.add('hidden')`), скрывая её.

Таким образом, пока функция `handleLogin` не выполнится успешно, панель с формой остается скрытой стилями.

### Дополнительная информация
**Механизм классов:**
*   `classList.add('class-name')`: Добавляет класс элементу.
*   `classList.remove('class-name')`: Удаляет класс.
*   `classList.toggle('class-name')`: Переключает класс (добавляет, если нет, и удаляет, если есть).
Это стандартный способ управления состоянием интерфейса (показать/скрыть, активировать/деактивировать) без изменения самого HTML-кода или прямых манипуляций со стилями через `style.display`.

---

## Вопрос 4
**Что написано в файле public\script.js с 1 по 28 строки, за что это отвечает и как работает?**

### Полное аргументированное объяснение
Этот блок кода отвечает за **инициализацию приложения**: объявление переменных состояния, поиск элементов интерфейса в DOM-дереве и назначение обработчиков событий (слушателей) на кнопки.

**Разбор по строкам:**

*   **Строки 1-4 (State):**
    ```javascript
    const state = {
        user: null,
        schema: null
    };
    ```
    Создается объект `state` для хранения глобальных данных приложения: текущего пользователя (`user`) и загруженной схемы формы (`schema`). Изначально они `null` (пустые).

*   **Строки 6-18 (UI Cache):**
    ```javascript
    const ui = {
        authPanel: document.getElementById('auth-panel'),
        // ... другие элементы
        resetBtn: document.getElementById('reset-form')
    };
    ```
    Создается объект `ui`, в который сохраняются ссылки на все важные HTML-элементы.
    *   `document.getElementById('id')`: Метод браузера, который находит элемент на странице по его уникальному ID.
    *   Это делается один раз при запуске, чтобы не искать элементы каждый раз, когда они понадобятся (оптимизация производительности).

*   **Строки 20-28 (Event Listeners):**
    ```javascript
    ui.loginBtn.addEventListener('click', handleLogin);
    ui.historyBtn.addEventListener('click', handleHistoryToggle);
    ui.submitBtn.addEventListener('click', handleSubmit);
    ui.resetBtn.addEventListener('click', () => { ... });
    ui.backBtn.addEventListener('click', handleBack);
    ```
    Назначаются обработчики событий.
    *   `addEventListener('click', function)`: Говорит браузеру: "Когда на этот элемент кликнут, запусти указанную функцию".
    *   Для кнопки сброса (`resetBtn`) используется стрелочная функция `() => { ... }`, которая очищает форму и восстанавливает значение поля "квартира", если пользователь авторизован.

### Дополнительная информация
**DOM (Document Object Model):**
Это представление HTML-страницы в виде дерева объектов, доступного для JavaScript. `document` — это корневой объект.
**События (Events):**
Браузер постоянно отслеживает действия пользователя (клики, ввод текста, прокрутка). `addEventListener` позволяет "подписаться" на эти события и реагировать на них кодом.

---

## Вопрос 5
**Что делают функции handleHistoryToggle(), handleBack(), handleLogin(), также объясни каждую строку в них, в файле public\script.js?**

### Полное аргументированное объяснение

#### 1. `handleHistoryToggle()`
**Назначение:** Открывает или закрывает панель истории показаний. Если открывает — загружает данные с сервера.

**Построчный разбор:**
```javascript
function handleHistoryToggle() {
    // Проверяем, есть ли у элемента истории класс 'hidden' (скрыт ли он сейчас)
    if (ui.history.classList.contains('hidden')) {
        // Если скрыт -> вызываем функцию загрузки истории (она же и покажет панель)
        fetchHistory();
    } else {
        // Если не скрыт (значит открыт) -> добавляем класс 'hidden', чтобы скрыть
        ui.history.classList.add('hidden');
    }
}
```

#### 2. `handleBack()`
**Назначение:** Выход из системы (разлогинивание). Сбрасывает интерфейс в исходное состояние.

**Построчный разбор:**
```javascript
function handleBack() {
    state.user = null; // Сбрасываем текущего пользователя в null
    ui.userLabel.textContent = ''; // Очищаем текст "Вы вошли как..."
    ui.form.innerHTML = ''; // Полностью удаляем сгенерированную форму из DOM
    ui.history.classList.add('hidden'); // Скрываем панель истории
    ui.history.innerHTML = ''; // Очищаем содержимое истории
    ui.appPanel.classList.add('hidden'); // Скрываем основную панель приложения
    ui.authPanel.classList.remove('hidden'); // Показываем панель авторизации
    ui.usernameInput.focus(); // Ставим курсор в поле ввода логина для удобства
}
```

#### 3. `handleLogin()`
**Назначение:** Обрабатывает вход пользователя. Проверяет ввод, сохраняет логин и запускает загрузку формы.

**Построчный разбор:**
```javascript
async function handleLogin() { // Объявлена как async, так как внутри есть await
    // Получаем текст из поля ввода и удаляем пробелы по краям (.trim())
    const username = ui.usernameInput.value.trim();

    // Если строка пустая (false), выводим предупреждение и выходим из функции
    if (!username) {
        alert('Введите номер квартиры/логин');
        return;
    }

    state.user = username; // Сохраняем введенный логин в глобальное состояние
    // Обновляем текст приветствия на экране
    ui.userLabel.textContent = `Вы вошли как: ${username}`;

    ui.authPanel.classList.add('hidden'); // Скрываем панель входа
    ui.appPanel.classList.remove('hidden'); // Показываем панель приложения

    // Ждем выполнения асинхронной функции загрузки схемы и отрисовки формы
    await loadSchemaAndRender();
}
```

### Дополнительная информация
*   `trim()`: Метод строк, удаляющий пробелы в начале и конце. Полезно, если пользователь случайно нажал пробел.
*   `innerHTML = ''`: Быстрый способ удалить все дочерние элементы внутри контейнера.

---

## Вопрос 6
**Что означает async function, как это работает и почему?**

### Полное аргументированное объяснение
Ключевое слово `async` перед объявлением функции (`async function`) делает функцию **асинхронной**.

**Как это работает:**
1.  **Всегда возвращает Promise:** Даже если вы вернете простое число `return 1`, асинхронная функция обернет его в `Promise.resolve(1)`.
2.  **Разрешает использование `await`:** Внутри такой функции можно использовать ключевое слово `await`. Оно "ставит на паузу" выполнение кода внутри этой функции (не блокируя весь браузер), пока промис справа от него не выполнится (не вернет результат или ошибку).

**Почему это нужно:**
JavaScript — однопоточный язык. Если бы мы выполняли долгие операции (например, запрос к серверу) синхронно, интерфейс страницы завис бы до получения ответа.
`async/await` — это современный, удобный синтаксис для работы с асинхронным кодом (вместо цепочек `.then().catch()`). Он позволяет писать асинхронный код так, будто он выполняется последовательно, что упрощает чтение и отладку.

### Дополнительная информация
**Пример:**
```javascript
async function getData() {
    // Ждем, пока fetch скачает данные. Браузер в это время может рисовать интерфейс.
    const response = await fetch('/api');
    // Код ниже выполнится ТОЛЬКО когда fetch завершится
    const data = await response.json();
    return data;
}
```

---

## Вопрос 7
**Объясни как работает эта строчка await loadSchemaAndRender();? Также напиши что делает эта функция.**

### Полное аргументированное объяснение
Строка `await loadSchemaAndRender();` делает следующее:
1.  Вызывает функцию `loadSchemaAndRender`.
2.  Ключевое слово `await` приостанавливает выполнение текущей функции (`handleLogin`), пока `loadSchemaAndRender` не завершит свою работу полностью (так как она тоже асинхронная).
3.  Это гарантирует, что мы не попытаемся делать что-то с формой до того, как она загрузится и отрисуется.

**Что делает функция `loadSchemaAndRender`:**
Она отвечает за получение структуры формы с сервера и её отображение.
1.  `fetch('/api/schema')`: Делает HTTP-запрос к серверу для получения файла `schema.json`.
2.  `res.ok`: Проверяет, успешен ли запрос (код ответа 200-299). Если нет — выбрасывает ошибку.
3.  `res.json()`: Читает ответ сервера и преобразует JSON-строку в JavaScript-объект.
4.  `state.schema = ...`: Сохраняет полученную схему в глобальное состояние.
5.  `renderForm(state.schema)`: Вызывает функцию отрисовки формы на основе полученных данных.
6.  `catch (err)`: Если на любом этапе произошла ошибка (нет интернета, ошибка сервера), выводит сообщение через `alert`.

### Дополнительная информация
Эта функция реализует паттерн "Загрузи и покажи". Разделение логики: одна функция управляет процессом (загрузка -> обработка -> рендер), а детали реализации (как именно рендерить) вынесены в `renderForm`.

---

## Вопрос 8
**Что делает функция function renderForm(schema), что за параметр передается?**

### Полное аргументированное объяснение
Функция `renderForm` отвечает за **генерацию HTML-кода формы** на основе переданных данных и вставку его на страницу.

**Параметр `schema`:**
Это JavaScript-объект (или массив), который описывает структуру формы. Он приходит с сервера (из файла `schema.json`). В нем указано, какие поля должны быть, как они сгруппированы и как называются.

**Что делает код:**
1.  `ui.form.innerHTML = '';`: Очищает контейнер формы от предыдущего содержимого.
2.  `if (!schema) return;`: Защита от ошибок — если схемы нет, функция ничего не делает.
3.  `ui.form.appendChild(buildNode(schema, []));`: Самая важная часть. Она вызывает рекурсивную функцию `buildNode`, которая превращает объект схемы в DOM-элемент (HTML), и добавляет этот элемент в форму.
4.  Блок с `apt`: Ищет поле с именем "квартира". Если пользователь уже авторизован (`state.user`), скрипт автоматически заполняет это поле его логином и делает поле доступным только для чтения (`readOnly = true`), чтобы его нельзя было изменить.

### Дополнительная информация
Это пример **Data-Driven UI** (интерфейс, управляемый данными). Мы не пишем HTML формы вручную (`<input>...`), а генерируем его программно. Это позволяет менять форму, просто изменив JSON-файл на сервере, без правки кода сайта.

---

## Вопрос 9
**Что делает функция function buildNode(node, pathParts), что за параметры передается, как код внутри работает?**

### Полное аргументированное объяснение
Это **рекурсивная функция**, которая строит часть интерфейса (DOM-дерево) для переданного узла схемы.

**Параметры:**
1.  `node`: Текущий объект (или часть объекта) из схемы, который нужно превратить в HTML.
2.  `pathParts`: Массив строк, представляющий "путь" к текущему полю (например, `['kitchen', 'cold_water']`). Нужен для того, чтобы потом собрать данные обратно в правильную структуру.

**Как работает код:**
1.  Создает контейнер `<fieldset>` (группа полей).
2.  Если у узла есть `name`, создает заголовок `<legend>`.
3.  **Цикл по ключам объекта (`node`):** Проходит по всем свойствам узла.
    *   Если ключ `resources` и это массив: Это вложенная структура (например, список счетчиков). Функция вызывает **саму себя** (`buildNode`) для каждого элемента массива, добавляя индекс в `pathParts`. (Рекурсия).
    *   Если значение — строка `'string'` или `'number'`: Это конечное поле ввода.
        *   Создает `<div>`, `<label>` (подпись) и `<input>`.
        *   Настраивает `<input>`: тип (текст или число), имя.
        *   **Важно:** Записывает в атрибут `data-path` путь к этому полю (через разделитель `|`), чтобы потом знать, куда записать введенное значение.
4.  Возвращает готовый HTML-элемент (`fieldset`), заполненный полями и подгруппами.

### Дополнительная информация
**Рекурсия:** Это когда функция вызывает саму себя. Здесь это идеально подходит, так как структура JSON может иметь любую глубину вложенности (группа внутри группы внутри группы...), и один и тот же код может обработать любой уровень.

---

## Вопрос 10
**Что делает функция function assignByPath(target, pathString, rawValue, type), что за параметры передается, как код внутри работает?**

### Полное аргументированное объяснение
Эта вспомогательная функция **записывает значение в глубоко вложенный объект**, создавая промежуточные объекты по мере необходимости. Она превращает плоский путь (строку) в структуру данных.

**Параметры:**
1.  `target`: Объект, в который мы записываем данные (наш результат).
2.  `pathString`: Строка пути, например `"kitchen|cold_water"`.
3.  `rawValue`: Значение из поля ввода (строка).
4.  `type`: Тип данных поля (`'number'` или `'string'`).

**Как работает код:**
1.  `pathString.split('|')`: Разбивает путь на массив ключей: `['kitchen', 'cold_water']`.
2.  **Цикл:** Идет по этим ключам.
3.  **Обработка массивов (`resources`):** Если встречает слово 'resources', понимает, что дальше идет индекс массива. Создает массив, если его нет, и переходит внутрь нужного элемента.
4.  **Навигация:** Если это не последний ключ в пути, проверяет, существует ли вложенный объект. Если нет — создает пустой `{}`. Сдвигает указатель `current` внутрь этого объекта.
5.  **Запись (последний ключ):** Если это последний ключ:
    *   Преобразует значение (если тип `number`, делает `Number(rawValue)`).
    *   Записывает значение в свойство объекта: `current[part] = value`.

### Дополнительная информация
Эта функция — обратная операция к тому, что делала `buildNode`. `buildNode` разворачивала структуру в плоские инпуты с путями, а `assignByPath` сворачивает инпуты обратно в структуру объекта для отправки на сервер.

---

## Вопрос 11
**Что делает функции async function handleSubmit(), async function fetchHistory()? Также напиши объяснение кода внутри них.**

### Полное аргументированное объяснение

#### 1. `handleSubmit()`
**Назначение:** Собирает данные из формы, формирует JSON и отправляет его на сервер (POST-запрос).

**Разбор кода:**
*   Проверка авторизации: `if (!state.user) ...`.
*   `ui.form.querySelectorAll('input[data-path]')`: Находит все поля ввода, у которых есть атрибут `data-path` (который мы задали в `buildNode`).
*   **Сбор данных:**
    ```javascript
    inputs.forEach(input => {
        assignByPath(payload, input.dataset.path, input.value, input.dataset.type);
    });
    ```
    Пробегает по всем инпутам и с помощью `assignByPath` собирает их значения в единый объект `payload`.
*   **Отправка:** `fetch('/api/records', ...)` отправляет POST-запрос с данными. В заголовке `x-username` передается имя пользователя.
*   **Обработка ответа:** Если успешно — выводит сообщение, очищает форму, восстанавливает логин в поле "квартира" и обновляет историю (`await fetchHistory()`). Если ошибка — `alert`.

#### 2. `fetchHistory()`
**Назначение:** Загружает список предыдущих показаний пользователя с сервера.

**Разбор кода:**
*   `if (!state.user) return;`: Если нет пользователя, ничего не делаем.
*   `fetch('/api/records', ...)`: GET-запрос к API. Передает имя пользователя в заголовке, чтобы сервер знал, чью историю отдавать.
*   `res.json()`: Парсит ответ.
*   `renderHistory(records)`: Вызывает функцию отрисовки полученных записей.
*   `ui.history.classList.remove('hidden')`: Показывает панель истории (если она была скрыта).

### Дополнительная информация
Обе функции используют `try...catch` для обработки ошибок сети или сервера, что является хорошей практикой (приложение не "падает" молча, а сообщает пользователю о проблеме).

---

## Вопрос 12
**Как работает функция function renderHistory(records), какие параметры передаются, что делает код?**

### Полное аргументированное объяснение
Функция отображает список исторических записей на странице.

**Параметры:**
*   `records`: Массив объектов-записей, полученный с сервера.

**Как работает код:**
1.  `ui.history.innerHTML = '';`: Очищает контейнер истории.
2.  **Проверка на пустоту:** Если массив пуст, выводит сообщение "Записей пока нет".
3.  **Цикл и реверс:** `records.slice().reverse().forEach(...)`.
    *   `.slice()`: Создает копию массива (чтобы не мутировать исходный).
    *   `.reverse()`: Переворачивает массив, чтобы новые записи были сверху.
    *   `.forEach()`: Для каждой записи выполняет код создания карточки.
4.  **Создание DOM-элементов:**
    *   Создает `div` с классом `history-card`.
    *   Создает заголовок с датой (`new Date(...).toLocaleString()`).
    *   Создает блок `<pre>`, куда помещает красиво отформатированный JSON самой записи (`JSON.stringify(entry, null, 2)`).
5.  `ui.history.appendChild(card)`: Добавляет созданную карточку в контейнер истории.

### Дополнительная информация
Использование тега `<pre>` (preformatted text) позволяет сохранить форматирование (отступы и переносы строк) JSON-строки, делая её читаемой для человека прямо на странице.

---

## Вопрос 13
**Какие свойства используются в стиле страницы, опиши каждый из них(что делает, для чего нужно)?**

### Полное аргументированное объяснение
В файле `public\style.css` используются различные CSS-свойства для оформления страницы. Вот основные из них:

1.  **Переменные CSS (`:root`)**:
    *   `--bg`, `--primary`, `--text-main` и т.д.: Определяют цветовую палитру и общие настройки (шрифты, радиусы). Это позволяет менять тему сайта в одном месте.

2.  **Блочная модель и позиционирование**:
    *   `box-sizing: border-box`: Включает отступы (`padding`) и границы (`border`) в общую ширину элемента. Это упрощает расчет размеров.
    *   `margin`: Внешние отступы. `margin: 0 auto` центрирует блок по горизонтали.
    *   `padding`: Внутренние отступы (расстояние от границы до контента).
    *   `max-width`: Ограничивает максимальную ширину контейнера (чтобы на больших экранах текст не растягивался слишком сильно).

3.  **Flexbox и Grid (Макет)**:
    *   `display: flex`: Включает гибкий контейнер. Используется для выравнивания элементов в ряд или колонку.
    *   `flex-direction: column`: Располагает элементы вертикально.
    *   `justify-content: space-between`: Распределяет элементы по краям контейнера (например, заголовок слева, кнопка справа).
    *   `align-items: center`: Выравнивает элементы по центру поперечной оси.
    *   `gap`: Задает расстояние между элементами внутри flex или grid контейнера.
    *   `display: grid`: Включает сеточный макет (используется в `.form-row`).
    *   `grid-template-columns: 1fr 2fr`: Делит пространство на две колонки: первая занимает 1 часть, вторая — 2 части.

4.  **Типографика**:
    *   `font-family`: Задает шрифт текста.
    *   `font-size`: Размер шрифта (`rem` — относительно корневого размера, `px` — пиксели).
    *   `font-weight`: Жирность шрифта (400 — обычный, 700 — жирный).
    *   `text-align`: Выравнивание текста (center, left, right).
    *   `text-transform: uppercase`: Делает все буквы заглавными.
    *   `line-height`: Межстрочный интервал.

5.  **Оформление**:
    *   `background-color`: Цвет фона.
    *   `color`: Цвет текста.
    *   `border`: Граница элемента (толщина, стиль, цвет).
    *   `border-radius`: Скругление углов.
    *   `box-shadow`: Тень элемента (создает эффект объема).

6.  **Интерактивность**:
    *   `cursor: pointer`: Меняет курсор на "руку" при наведении (для кнопок).
    *   `transition`: Плавная анимация изменений свойств (например, цвета при наведении).
    *   `:hover`: Псевдокласс, применяющий стили при наведении мыши.
    *   `:focus`: Псевдокласс для элемента в фокусе (например, активное поле ввода).

### Дополнительная информация
Использование CSS-переменных (`var(--name)`) — современный стандарт. Это делает код чище и облегчает поддержку (например, добавление темной темы).

---

## Вопрос 14
**Как работает сервер, как запускается, какие модули используются, почему эти модули используются?**

### Полное аргументированное объяснение
Сервер написан на платформе **Node.js** с использованием фреймворка **Express**.

**Как запускается:**
Сервер запускается командой `node server/server.js` (или через скрипт в `package.json`).
В конце файла есть код:
```javascript
ensureStorage().then(() => {
    app.listen(PORT, () => { ... });
});
```
Сначала проверяется наличие папки для данных (`ensureStorage`), и только после успешного создания запускается прослушивание порта (`app.listen`).

**Используемые модули:**
1.  **`express`**:
    *   *Зачем:* Это самый популярный веб-фреймворк для Node.js. Он упрощает создание веб-сервера, маршрутизацию (обработку URL вроде `/api/records`) и работу с запросами/ответами. Без него пришлось бы писать много низкоуровневого кода.
2.  **`path`**:
    *   *Зачем:* Встроенный модуль Node.js для работы с путями к файлам. Он нужен, чтобы правильно склеивать пути (например, `path.join(__dirname, 'public')`) независимо от операционной системы (Windows использует `\`, Linux `/`).
3.  **`fs` (File System)**:
    *   *Зачем:* Встроенный модуль для работы с файловой системой.
4.  **`fs/promises`**:
    *   *Зачем:* Современная версия модуля `fs`, которая возвращает промисы. Это позволяет использовать удобный синтаксис `async/await` для чтения и записи файлов, вместо старых колбэков.

### Дополнительная информация
Node.js — это среда выполнения JavaScript вне браузера. Она позволяет писать серверную часть (бэкенд) на том же языке, что и клиентскую (фронтенд).

---

## Вопрос 15
**Что происходит в строках с 1 по 16? Дай полное описание каждому методу в этих строчках.**

### Полное аргументированное объяснение
Этот блок кода отвечает за **импорт зависимостей и настройку конфигурации**.

*   **Строки 1-4 (Импорты):**
    *   `require('express')`: Подключает библиотеку Express.
    *   `require('path')`: Подключает встроенный модуль для работы с путями.
    *   `require('fs')`: Подключает модуль файловой системы (нужен для констант вроде `fs.constants.F_OK`).
    *   `require('fs/promises')`: Деструктуризация. Из промис-версии модуля `fs` мы сразу достаем нужные функции: `readFile` (читать), `writeFile` (писать), `mkdir` (создать папку), `access` (проверить доступ).

*   **Строки 6-7 (Инициализация):**
    *   `const app = express();`: Создает экземпляр приложения Express. Это главный объект, к которому мы будем добавлять настройки и маршруты.
    *   `const PORT = process.env.PORT || 3000;`: Определяет порт. Если в переменных окружения (`process.env`) задан порт (например, на хостинге), берет его. Иначе использует 3000.

*   **Строки 9-13 (Пути):**
    *   `__dirname`: Системная переменная, содержащая путь к папке, где лежит текущий файл (`server.js`).
    *   `path.join(...)`: Склеивает части пути в один корректный путь.
    *   `ROOT_DIR`: Папка проекта (на уровень выше `server`).
    *   `PUBLIC_DIR`: Папка с фронтендом (`public`).
    *   `DATA_DIR`: Папка для хранения данных (`server/data`).
    *   `DB_FILE`: Путь к файлу базы данных (`readings.json`).
    *   `SCHEMA_FILE`: Путь к файлу схемы (`schema.json`).

*   **Строки 15-16 (Middleware):**
    *   `app.use(express.json())`: Подключает "парсер" JSON. Это позволяет серверу понимать данные, приходящие в формате JSON в теле POST-запросов (превращает их в `req.body`).
    *   `app.use(express.static(PUBLIC_DIR))`: Настраивает раздачу статических файлов. Если пользователь запросит `/style.css`, сервер сам найдет его в папке `public` и отдаст.

### Дополнительная информация
`Middleware` (промежуточное ПО) — это функции, которые выполняются между получением запроса и отправкой ответа.

---

## Вопрос 16
**Что делает функция ensureStorage()?**

### Полное аргументированное объяснение
Функция `ensureStorage` гарантирует, что **файловая структура для хранения данных существует** перед запуском сервера.

**Как работает:**
1.  `await mkdir(DATA_DIR, { recursive: true });`: Пытается создать папку `data`. Флаг `recursive: true` означает, что если папка уже есть, ошибки не будет.
2.  `await access(DB_FILE, fs.constants.F_OK);`: Проверяет, существует ли файл базы данных (`readings.json`).
3.  `catch (err)`: Если проверка `access` выдала ошибку (файла нет), срабатывает блок `catch`.
4.  `await writeFile(DB_FILE, '[]', 'utf8');`: Создает новый файл и записывает в него пустой массив `[]`. Это инициализация пустой базы данных.

**Зачем нужно:**
Чтобы сервер не "упал" с ошибкой при первой попытке прочитать или записать данные, если файла еще нет.

---

## Вопрос 17
**Что делает функции readJson(filePath, fallback = null), writeJson(filePath, payload), какие параметры в них входят, что это за параметры?**

### Полное аргументированное объяснение

#### `readJson(filePath, fallback = null)`
**Назначение:** Читает JSON-файл и преобразует его в объект JavaScript.
**Параметры:**
*   `filePath` (String): Путь к файлу.
*   `fallback` (Any): Значение по умолчанию. Если чтение файла не удалось (ошибка), функция вернет это значение вместо выброса ошибки. По умолчанию `null`.
**Работа:**
Читает файл как текст (`utf8`), затем делает `JSON.parse()`. Если ошибка — возвращает `fallback` или пробрасывает ошибку дальше.

#### `writeJson(filePath, payload)`
**Назначение:** Записывает данные в файл в формате JSON.
**Параметры:**
*   `filePath` (String): Путь к файлу.
*   `payload` (Object/Array): Данные для записи.
**Работа:**
Преобразует данные в красивую строку (`JSON.stringify(..., null, 2)`) и перезаписывает файл.

### Дополнительная информация
Эти функции — обертки (wrappers) над стандартными методами `fs`. Они упрощают код в остальных частях сервера, скрывая детали работы с файловой системой и JSON.

---

## Вопрос 18
**Что делает функция respondError(res, status, message), что за параметры в нее входят?**

### Полное аргументированное объяснение
Это вспомогательная функция для **отправки стандартизированного ответа об ошибке** клиенту.

**Параметры:**
1.  `res` (Object): Объект ответа Express (response object). Через него мы отправляем данные браузеру.
2.  `status` (Number): HTTP-код статуса ошибки (например, 404 - не найдено, 500 - ошибка сервера, 400 - плохой запрос).
3.  `message` (String): Текстовое описание ошибки для пользователя.

**Что делает:**
`res.status(status).json({ status: 'error', message });`
Устанавливает HTTP-код ответа и отправляет JSON-объект вида:
```json
{
  "status": "error",
  "message": "Текст ошибки"
}
```
Это позволяет фронтенду легко понимать, что произошла ошибка, и показывать сообщение пользователю.

---

## Вопрос 19
**Что делает код с 46 по 84 строчку? Для чего это нужно, какую функцию выполняет?**

### Полное аргументированное объяснение
Этот блок кода определяет **API-маршруты (эндпоинты)** сервера. Это "ручки", за которые дергает фронтенд.

1.  **`app.get('/api/schema', ...)` (строки 46-52):**
    *   Обрабатывает GET-запрос на получение схемы формы.
    *   Читает файл `schema.json` и отправляет его содержимое клиенту.
    *   Нужно для построения динамической формы на фронтенде.

2.  **`app.post('/api/records', ...)` (строки 54-70):**
    *   Обрабатывает POST-запрос на **сохранение показаний**.
    *   Получает имя пользователя из заголовка `x-username`.
    *   Берет данные из тела запроса (`req.body`), добавляет к ним имя пользователя и текущую дату (`meta`).
    *   Читает текущую базу (`readJson`), добавляет новую запись в массив (`push`) и сохраняет обратно в файл (`writeJson`).

3.  **`app.get('/api/records', ...)` (строки 72-84):**
    *   Обрабатывает GET-запрос на **получение истории**.
    *   Читает всю базу данных.
    *   Фильтрует записи (`filter`), оставляя только те, которые принадлежат текущему пользователю (`entry['квартира'] === username`).
    *   Отправляет массив записей клиенту.

### Дополнительная информация
Здесь реализован простейший CRUD (Create, Read) API. Сервер выступает посредником между файлом данных и браузером, обеспечивая логику сохранения и фильтрации.

---

## Вопрос 20
**Как работает код с 86 по 92 строки, для чего он нужен?**

### Полное аргументированное объяснение
Этот код отвечает за **запуск сервера**.

```javascript
ensureStorage().then(() => {
    app.listen(PORT, () => {
        console.log(`Server is running at http://localhost:${PORT}`);
    });
}).catch(err => {
    console.error('Failed to start server:', err);
});
```

**Как работает:**
1.  Сначала вызывается `ensureStorage()`. Это асинхронная операция (возвращает промис).
2.  `.then(() => { ... })`: Этот блок выполнится **только после того**, как `ensureStorage` успешно завершится (создаст папку и файл). Это важно: мы не хотим запускать сервер, если некуда писать данные.
3.  `app.listen(PORT, ...)`: Команда Express запустить веб-сервер и начать слушать входящие соединения на порту 3000.
4.  `.catch(...)`: Если при создании файлов произошла ошибка, сервер не запустится, а в консоль выведется сообщение об ошибке.

**Итог:** Это точка входа приложения, гарантирующая безопасный старт.

---

## Вопрос 21
**Для чего нужна папка node_modules, за что она отвечает? А также для чего нужны package-lock.json и package.json?**

### Полное аргументированное объяснение
Эти три элемента составляют основу управления зависимостями в Node.js проектах.

1.  **`package.json` (Паспорт проекта):**
    Это главный конфигурационный файл. Он содержит:
    *   **Метаданные:** Имя проекта, версию, автора, лицензию.
    *   **Скрипты:** Команды для запуска (`start`), тестирования и сборки.
    *   **Список зависимостей (`dependencies`):** Перечень библиотек, необходимых для работы проекта (например, `express`). Здесь указаны *допустимые диапазоны* версий (например, "версия 4.0.0 или выше").

2.  **`node_modules` (Склад библиотек):**
    Это папка, куда физически скачиваются все библиотеки, указанные в `package.json`, а также *их* зависимости (зависимости зависимостей).
    *   Она создается автоматически при запуске команды `npm install`.
    *   Она может весить очень много (сотни мегабайт), поэтому её **никогда** не передают другим разработчикам и не загружают в Git (она должна быть в `.gitignore`).

3.  **`package-lock.json` (Фиксация версий):**
    Этот файл создается автоматически npm. Он фиксирует **точные** версии всех установленных библиотек и структуру дерева зависимостей.
    *   Если в `package.json` написано "версия примерно 4.x", то в `package-lock.json` будет записано "установлена версия 4.17.1, скачана по такой-то ссылке, контрольная сумма такая-то".
    *   Это гарантирует, что у всех разработчиков в команде и на сервере будет установлен **абсолютно одинаковый** набор библиотек, и проект будет работать предсказуемо.

### Дополнительная информация
*   **NPM (Node Package Manager):** Инструмент, который читает эти файлы и управляет папкой `node_modules`.
*   **Почему `node_modules` такая большая?** Потому что каждая библиотека может тянуть за собой десятки других маленьких библиотек. Это называется "дерево зависимостей".
*   **Процесс работы:** Когда вы скачиваете чужой проект, в нем нет `node_modules`. Вы запускаете `npm install`, npm читает `package.json` и `package-lock.json`, скачивает всё нужное из интернета и создает папку `node_modules`.
